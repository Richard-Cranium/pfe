#ifndef PFE_ENGINE_SET_H
#define PFE_ENGINE_SET_H 20091024
/* generated by make-header.py from ../../c/engine-set.c */

#include <pfe/pfe-base.h>

/**
 * -- setup forth memory and start up.
 *
 *  Copyright (C) Tektronix, Inc. 1998 - 2003.
 *  Copyright (C) 2005 - 2008 Guido U. Draheim <guidod@gmx.de>
 *
 *  @see     GNU LGPL
 *  @author  Guido U. Draheim            (modified by $Author: guidod $)
 *  @version $Revision: 533 $
 *     (modified $Date: 2009-10-24 14:53:14 +0200 (Sa, 24 Okt 2009) $)
 *
 *  @description
 *  Process options via options block (set in option-set), get memory
 *  and init variables, and finally start up the interpret loop of PFE
 */

#ifdef __cplusplus
extern "C" {
#endif




/** boot_includes
 * This routine is ususally run right after p4_boot_system. Perhaps
 * some other boot routines have run, and then script-files shall
 * be included - we set the environment => MARKER => EMPTY in this
 * routine so you can always go back to the dictionary state just
 * before this routine. That is actually done in => COLD for example.
 */
extern void FXCode(p4_script_files);

_extern  p4_threadP p4_main_threadP ; /*=*/

/** initialize memory map to a given memory block */
extern void p4_SetDictMem (p4_threadP thread, void* dictmem, long size); /*{*/

/**
 * wrapping a catch domain around p4_script_files above. The lower
 * routine is also called from COLD which does run EMPTY followed
 * by re-including the SCRIPT-FILE to re-initialize the system */
extern int p4_run_script_files(p4_Thread* th); /*{*/

/**
 * init and execute the previously allocated forth-maschine,
 * e.g. pthread_create(&thread_id,0,p4_Exec,threadP);
 *
 * The following words have been extracted from a big boot init
 * procedure previously existing in PFE. In the boot_system we
 * do initialize all inputs/outputs and load the wordset extensions
 * and the boot-preinit-block or boot-preinit-script. After that,
 * we run script_files to init the application code, and finally
 * the application is started - and if no APPLICATION was set then
 * we do the fallback to the forth interactive INTERPRET loop. The
 * latter is the usual case, use BYE to exit that inifinite loop.
 *
 * When the mainloop returns, we run the cleanup-routines. They are
 * registered seperatly so they can be run asynchronously - if the
 * application has broken down or it blocks hard on some hardware
 * then we can still run cleanup code in a new forthish context.
 */
extern int p4_Exec(p4_threadP th); /*{*/

/** create a Forth-VM from the given options */
extern int p4_InitVM(p4_threadP th, p4_Session* set); /*{*/

/** execute a Forth-VM with an input-loop */
extern int p4_LoopVM(p4_threadP th); /*{*/

/** execute a Forth-VM for the given EVALUATE */
extern int p4_Evaluate(p4_threadP th, const p4_char_t* p, int n); /*{*/

/** destroy a Forth-VM */
extern int p4_DeinitVM(p4_threadP th); /*{*/

#ifdef __cplusplus
} /* extern "C" */
#endif


#endif
